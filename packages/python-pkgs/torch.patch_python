diff -uNr pytorch-v1.12.1/torch/csrc/init_flatbuffer_module.cpp pytorch-v1.12.1.mod/torch/csrc/init_flatbuffer_module.cpp
--- pytorch-v1.12.1/torch/csrc/init_flatbuffer_module.cpp	2022-09-05 00:06:55.771017936 +0900
+++ pytorch-v1.12.1.mod/torch/csrc/init_flatbuffer_module.cpp	2022-08-06 04:37:12.000000000 +0900
@@ -27,7 +27,7 @@
   std::shared_ptr<char> bytes_copy(
       static_cast<char*>(_aligned_malloc(size, FLATBUFFERS_MAX_ALIGNMENT)),
       _aligned_free);
-#elif defined(__APPLE__) || defined(__ANDROID__)
+#elif defined(__APPLE__)
   void* p;
   ::posix_memalign(&p, FLATBUFFERS_MAX_ALIGNMENT, size);
   TORCH_INTERNAL_ASSERT(p, "Could not allocate memory for flatbuffer");
diff -uNr pytorch-v1.12.1/torch/lib/libshm/manager.cpp pytorch-v1.12.1.mod/torch/lib/libshm/manager.cpp
--- pytorch-v1.12.1/torch/lib/libshm/manager.cpp	2022-08-06 04:37:12.000000000 +0900
+++ pytorch-v1.12.1.mod/torch/lib/libshm/manager.cpp	2022-09-05 00:06:07.159036924 +0900
@@ -25,6 +25,65 @@
 #define DEBUG(...) (void)0
 #endif
 
+static int shm_unlink(const char *name) {
+    size_t namelen;
+    char *fname;
+
+    /* Construct the filename.  */
+    while (name[0] == '/') ++name;
+
+    if (name[0] == '\0') {
+        /* The name "/" is not supported.  */
+        errno = EINVAL;
+        return -1;
+    }
+
+    namelen = strlen(name);
+    fname = (char *) alloca(sizeof("@TERMUX_PREFIX@/tmp/") - 1 + namelen + 1);
+    memcpy(fname, "@TERMUX_PREFIX@/tmp/", sizeof("@TERMUX_PREFIX@/tmp/") - 1);
+    memcpy(fname + sizeof("@TERMUX_PREFIX@/tmp/") - 1, name, namelen + 1);
+
+    return unlink(fname);
+}
+
+static int shm_open(const char *name, int oflag, mode_t mode) {
+    size_t namelen;
+    char *fname;
+    int fd;
+
+    /* Construct the filename.  */
+    while (name[0] == '/') ++name;
+
+    if (name[0] == '\0') {
+        /* The name "/" is not supported.  */
+        errno = EINVAL;
+        return -1;
+    }
+
+    namelen = strlen(name);
+    fname = (char *) alloca(sizeof("@TERMUX_PREFIX@/tmp/") - 1 + namelen + 1);
+    memcpy(fname, "@TERMUX_PREFIX@/tmp/", sizeof("@TERMUX_PREFIX@/tmp/") - 1);
+    memcpy(fname + sizeof("@TERMUX_PREFIX@/tmp/") - 1, name, namelen + 1);
+
+    fd = open(fname, oflag, mode);
+    if (fd != -1) {
+        /* We got a descriptor.  Now set the FD_CLOEXEC bit.  */
+        int flags = fcntl(fd, F_GETFD, 0);
+        flags |= FD_CLOEXEC;
+        flags = fcntl(fd, F_SETFD, flags);
+
+        if (flags == -1) {
+            /* Something went wrong.  We cannot return the descriptor.  */
+            int save_errno = errno;
+            close(fd);
+            fd = -1;
+            errno = save_errno;
+        }
+    }
+
+    return fd;
+}
+
 struct ClientSession {
   ClientSession(ManagerSocket s) : socket(std::move(s)), pid(0) {}
 
